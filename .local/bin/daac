#!/usr/bin/env amm

/**
 * Download at all costs.
 *
 * requires http://www.lihaoyi.com/Ammonite/
 */

import java.net.HttpURLConnection.HTTP_PARTIAL
import java.nio.file.StandardCopyOption.REPLACE_EXISTING
import java.nio.file.StandardOpenOption._
import java.nio.file.{Files, Paths}

import scala.concurrent.ExecutionContext.Implicits.global
import scala.concurrent._
import scala.concurrent.duration.Duration
import scala.math.{min, pow}
import scala.util.{Failure, Random, Success, Try}
import scalaj.http._

@main
def main(url: String) = {
  val request = leafReq(url)

  val fileName = request.url.split('/').last
  val head = request.method("HEAD").asString
  if (!head.isSuccess) {
    throw new AssertionError(s"HEAD request failed: $head")
  }
  
  val acceptRanges = head.header("Accept-Ranges")
    .getOrElse(throw new AssertionError("No Accept-Ranges"))
  val contentLength = head.header("Content-Length").map(_.toInt)
    .getOrElse(throw new AssertionError("No Content-Length"))

  println(s"Downloading ${request.url}")

  val splitSize = 1 << 17
  val splits = {
    val last = contentLength - 1
    for {
      i <- 0 until contentLength by splitSize
    } yield {
      val start = i
      val end = {
        val e = i + splitSize - 1
        if (e > last) last else e
      }
      request.header("Range", s"$acceptRanges=$start-$end")
    }
  }

  val downloads = splits.map { request =>
    download(request)
  }

  val outFile = Files.createTempFile("daac", "out")

  downloads.zipWithIndex.foreach { case (download, index) =>
    val part = Await.result(download, Duration.Inf)
    Files.write(outFile, Files.readAllBytes(part), CREATE, APPEND)
  }

  val destFile = Paths.get(sys.props("user.dir")).resolve(fileName)
  Files.move(outFile, destFile, REPLACE_EXISTING)

  println(s"Saved to $destFile")
}

def leafReq(loc: String): HttpRequest = {
  val req = Http(loc)
  val head = req.method("HEAD").asBytes
  if (head.isRedirect) {
    head.location.map(leafReq).get
  } else {
    req
  }
}

def download(req: HttpRequest) = Future {
  retry() {
    val response = blocking {
      req.asBytes
    }

    if (response.code != HTTP_PARTIAL) {
      throw new AssertionError(
        s"Expected $HTTP_PARTIAL but got ${response.code}")
    }

    val contentLength = response.header("Content-Length")
      .map(_.toInt)
      .getOrElse(throw new AssertionError("No Content-Length"))

    require(contentLength == response.body.length,
      s"Expected $contentLength bytes but downloaded ${response.body.length}.")

    val tmpFile = Files.createTempFile("daac", "tmp")
    tmpFile.toFile.deleteOnExit()
    Files.write(tmpFile, response.body)
    tmpFile
  }
}

val MaxBackoffMs = 10000
val BackoffSlotMs = 100
val MaxBackoffSlots = Stream
  .from(1)
  .filter(n => (pow(2, n).toInt - 1) * BackoffSlotMs > MaxBackoffMs)
  .head

@scala.annotation.tailrec
def retry[T](backoffSlots: Int = 0)(f: => T): T = {
  Try {
    if (backoffSlots > 0) {
      Thread.sleep(
        min(
          MaxBackoffMs,
          Random.nextInt(
            pow(2, min(MaxBackoffSlots, backoffSlots)).toInt - 1
          ) * BackoffSlotMs
        )
      )
    }

    f
  } match {
    case Success(result) => result
    case Failure(ex) => ex match {
      case ex: AssertionError => throw ex
      case cause =>
        if ((backoffSlots + 1) % 10 == 0) {
          println(s"Try ${backoffSlots + 1} failed. $cause")
        }
        retry(backoffSlots + 1)(f)
    }
  }
}
